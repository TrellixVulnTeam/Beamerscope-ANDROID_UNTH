//
// Created by Benedict Diederich on 17.08.16.
//

#include "opencv2/core.hpp"
#include "opencv2/core/utility.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"

#include "jni_qDPC.h"

#include <iostream>
#include <complex>
#include <ctime>
#include <sys/stat.h>
#include <string>

#include "cvComplex.h"
#include "common.h"


using namespace cv;
using namespace std;



/* C++ program to calculate the quantative DPC
 Updated 5/5/2015 WALLER GROUP
 */

static int leftList[30] = {159,160,180,181,182,201,202,203,223,224,225,226,246,247,248,249,270,271,272,292,293,294,295,315,316,317,338,339,340,361};
static int rightList[30] = {161,162,183,184,204,205,206,227,228,229,250,251,252,253,273,274,275,276,296,297,298,299,318,319,320,321,341,342,343,362};
static int topList[30] = {270,271,272,273,274,275,276,292,293,294,295,296,297,298,299,315,316,317,318,319,320,321,338,339,340,341,342,343,361,362};
static int bottomList[30] = {159,160,161,162,180,181,182,183,184,201,202,203,204,205,206,223,224,225,226,227,228,229,246,247,248,249,250,251,252,253};

// CellScope Image Cropping Sizes
static cv::Rect CellScopeCropHorz(600, 205, 2050, 2050);
static cv::Rect CellScopeCropVert(205, 590, 2050, 2050);



float zMin, zMax, zStep;
string datasetRoot;//folder of input images

Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
//Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
//Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

class R_image{

public:
    cv::Mat Image;
    int led_num;
    float tan_x;
    float tan_y;
};

//Check if file exists
inline bool exists_test (const std::string& name) {
    struct stat buffer;
    return (stat (name.c_str(), &buffer) == 0);
}



void computeFocusDPC(vector<R_image> iStack, int fileCount, float z, int width, int height, int xcrop, int ycrop, Mat* results) {
    int newWidth = width;
    int newHeight = height;

    cv::Mat bf_result = cv::Mat(newHeight, newWidth, CV_16UC3, double(0));//CV_16UC3 = 16-bit pixels, unsigned, 3 channels
    cv::Mat dpc_result_tb = cv::Mat(newHeight, newWidth, CV_16SC1,double(0));//16-bit pixels, signed, 1 channel
    cv::Mat dpc_result_lr = cv::Mat(newHeight, newWidth, CV_16SC1,double(0));

    cv::Mat bf_result8 = cv::Mat(newHeight, newWidth, CV_8UC3);
    cv::Mat dpc_result_tb8 = cv::Mat(newHeight, newWidth, CV_8UC1);
    cv::Mat dpc_result_lr8 = cv::Mat(newHeight, newWidth, CV_8UC1);

    cv::Mat img;
    cv::Mat img16;
    cv::Mat shifted = cv::Mat(iStack[0].Image.rows, iStack[0].Image.cols, CV_16UC3,double(0));
    vector<Mat> channels(3);

    for (int idx = 0; idx < fileCount; idx++)  {
        // Load image, convert to 16 bit grayscale image
        img = iStack[idx].Image;
        // Get hole number
        int holeNum = iStack[idx].led_num;

        // Calculate shift based on array coordinates and desired z-distance
        int xShift = (int) round(z*iStack[idx].tan_x);
        int yShift = (int) round(z*iStack[idx].tan_y);

        // Shift the Image in x and y
        circularShift(img, shifted, yShift, xShift);

        // Add Brightfield image
        cv::add(bf_result, shifted, bf_result);

        // Convert shifted to b/w for DPC
        split(shifted, channels);
        channels[1].convertTo(channels[1],dpc_result_lr.type());

        //Checks if on left/right, top/bottom, adds/subtracts as appropriate
        if (find(leftList, leftList + 30, holeNum) != leftList + 30)
            cv::add(dpc_result_lr, channels[1], dpc_result_lr);
        else
            cv::subtract(dpc_result_lr, channels[1], dpc_result_lr);

        if (find(topList, topList + 30, holeNum) != topList + 30)
            cv::add(dpc_result_tb, channels[1], dpc_result_tb);
        else
            cv::subtract(dpc_result_tb, channels[1], dpc_result_tb);

    }

    // Scale the values to 8-bit images
    double min_1, max_1, min_2, max_2, min_3, max_3;

    //sets min_1 and max_1 to be the min and max values of image
    cv::minMaxLoc(bf_result, &min_1, &max_1);
    //normalize based on min_1 and max_1
    bf_result.convertTo(bf_result8, CV_8UC4, 255/(max_1 - min_1), - min_1 * 255.0/(max_1 - min_1));

    cv::minMaxLoc(dpc_result_lr.reshape(1), &min_2, &max_2);
    dpc_result_lr.convertTo(dpc_result_lr8, CV_8UC4, 255/(max_2 - min_2), -min_2 * 255.0/(max_2 - min_2));

    cv::minMaxLoc(dpc_result_tb.reshape(1), &min_3, &max_3);
    dpc_result_tb.convertTo(dpc_result_tb8, CV_8UC4, 255/(max_3 - min_3), -min_3 * 255.0/(max_3 - min_3));

    results[0] = bf_result8;
    results[1] = dpc_result_lr8;
    results[2] = dpc_result_tb8;

}

/*Calculate the DPC of two images */
cv::Mat calcDPC( cv::Mat image1, cv::Mat image2)
{

    //std::cout << image1.type() << endl;
    //std::cout << image2.type() << endl;
    //cv::cvtColor(image1,image1,COLOR_BGR2GRAY);//convert to grayscale
    //cv::cvtColor(image2,image2,COLOR_BGR2GRAY);

    image1.convertTo(image1,CV_32FC1);
    image2.convertTo(image2,CV_32FC1);

    cv::Mat tmp1, tmp2;
    cv::subtract(image1, image2, tmp1);
    cv::add(image1, image2, tmp2);

    cv::Mat output;
    cv::divide(tmp1,tmp2,output);

    tmp1.release();//free memory
    tmp2.release();

    // Crop the ROI to a circle to get rid of noise
    int16_t circPad = 100;
    cv::Mat circMask(output.size(),CV_32FC1,cv::Scalar(0));
    cv::Point center(cvRound(output.rows/2),cvRound(output.cols/2));
    //circle(Mat& img, Point center, int radius, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
    cv::circle(circMask, center, cvRound(output.rows/2)-circPad ,cv::Scalar(1.0), -1,8,0);
    cv::multiply(output,circMask,output);


    //normalize
    double min_1, max_1;
    cv::minMaxLoc(output, &min_1, &max_1);
    output.convertTo(output, CV_8UC1, 255/(max_1 - min_1), - min_1 * 255.0/(max_1 - min_1));

    return output;
}

cv::Mat qDPC_loop(vector<cv::Mat>dpcList, vector<cv::Mat>transferFunctionList, double reg)
{
    clock_t begin = clock();
    vector<Mat> complexPlanes;

    Mat h[2];
    Mat planes[2];

    // Initialize Results
    Mat ph_dpc_ft_real = Mat::zeros(dpcList.at(0).size(), CV_64F);
    Mat ph_dpc_ft_imag = Mat::zeros(dpcList.at(0).size(), CV_64F);

    Mat dpcComplex, tmp;

    vector<cv::Mat> complexTransferFunctionList(dpcList.size());
    vector<cv::Mat> dpcFtList(dpcList.size());
    vector<cv::Mat> dpcFtRealList(dpcList.size());
    vector<cv::Mat> dpcFtImagList(dpcList.size());

    Mat padded;
    //expand input image to optimal size
    int m = getOptimalDFTSize( dpcList.at(0).rows );
    int n = getOptimalDFTSize( dpcList.at(0).cols ); // on the border add zero values

    for (int idx = 0; idx<2; idx++)
    {
        //void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar& value=Scalar() )
        copyMakeBorder(transferFunctionList.at(idx), padded, 0, m - transferFunctionList.at(idx).rows, 0, n - transferFunctionList.at(idx).cols, BORDER_CONSTANT, Scalar::all(0));

        copyMakeBorder(dpcList.at(idx), padded, 0, m - dpcList.at(idx).rows, 0, n - dpcList.at(idx).cols, BORDER_CONSTANT, Scalar::all(0));

        // Take Fourier Transforms of DPC Images
        planes[0] = Mat_<double>(dpcList.at(idx));
        planes[1] = Mat::zeros(dpcList.at(idx).size(), CV_64F);


        //merge array of Mats into one Mat. 2 refers to size of array.
        merge(planes, 2, dpcComplex);
        dft(dpcComplex, dpcComplex);
        split(dpcComplex, complexPlanes);
        complexPlanes[0].copyTo(dpcFtRealList.at(idx));
        complexPlanes[1].copyTo(dpcFtImagList.at(idx));
        //dpcFtImagList.at(idx) = complexPlanes[1];

        //std::cout << "Index is: " << idx << //std::endl;
        cout << dpcFtImagList.at(idx).at<double>(500,500) <<endl;

    }
    cout << "After assignment:" <<endl;
    cout << dpcFtImagList.at(0).at<double>(500,500) <<endl;
    cout << dpcFtImagList.at(1).at<double>(500,500) <<endl;

    // #pragma omp parallel for
    for (int i=0; i < dpcComplex.cols; i++){
        for (int j=0; j < dpcComplex.rows; j++){
            std::complex<double> H_sum = std::complex<double>(0,0);
            std::complex<double> Hi_sum = std::complex<double>(0,0);
            std::complex<double> I_sum = std::complex<double>(0,0);
            std::complex<double> result;

            //get value of each transfer function at (i,j)
            H_sum += std::complex<double>(0,transferFunctionList.at(0).at<double>(i,j));
            Hi_sum += std::complex<double>(0,-1*transferFunctionList.at(0).at<double>(i,j));
            I_sum += std::complex<double>(dpcFtRealList.at(0).at<double>(i,j),dpcFtImagList.at(0).at<double>(i,j));

            /*
             //std::cout << "TF1:" << //std::endl;
             //std::cout << "I_1 = " << //std::complex<double>(dpcFtRealList.at(0).at<double>(i,j),dpcFtImagList.at(0).at<double>(i,j)) << //std::endl;
             //std::cout << "H_1 = " << //std::complex<double>(0,transferFunctionList.at(0).at<double>(i,j)) << //std::endl;
             //std::cout << "Hi_1 = " << //std::complex<double>(0,-1*transferFunctionList.at(0).at<double>(i,j)) << //std::endl;
             */

            H_sum += std::complex<double>(0,transferFunctionList.at(1).at<double>(i,j));
            Hi_sum += std::complex<double>(0,-1*transferFunctionList.at(1).at<double>(i,j));
            I_sum += std::complex<double>(dpcFtRealList.at(1).at<double>(i,j),dpcFtImagList.at(1).at<double>(i,j));

            /*
             //std::cout << "TF2:" << //std::endl;
             //std::cout << "I_2 = " << //std::complex<double>(dpcFtRealList.at(1).at<double>(i,j),dpcFtImagList.at(1).at<double>(i,j)) << //std::endl;
             //std::cout << "H_2 = " << //std::complex<double>(0,transferFunctionList.at(1).at<double>(i,j)) << //std::endl;
             //std::cout << "Hi_2 = " << //std::complex<double>(0,-1*transferFunctionList.at(1).at<double>(i,j)) << //std::endl;
             */

            result = ((I_sum*Hi_sum)/(abs(H_sum)*abs(H_sum) + reg));

            //don't let threads execute this at same time
            //#pragma omp critical
            {
                //set result pixels
                ph_dpc_ft_real.at<double>(i,j) = result.real();
                ph_dpc_ft_imag.at<double>(i,j) = result.imag();
            }
        }
    }

    Mat ph_complex_ft, ph_complex;
    planes[0] = ph_dpc_ft_real;
    planes[1] = ph_dpc_ft_imag;

    merge(planes, 2, ph_complex_ft);
    dft(ph_complex_ft, ph_complex, DFT_INVERSE);
    split(ph_complex, complexPlanes);

    return complexPlanes[0]; // Real Part
}


Mat qDPC(Mat dpc11, Mat dpc12, Mat dpc21, Mat dpc22, Mat trans1, Mat trans2)
{
// DEBUG

/*
    LOGD("dpc11");
    printMat(dpc11);

    LOGD("dpc12");
    printMat(dpc12);

    LOGD("dpc21");
    printMat(dpc21);

    LOGD("dpc22");
    printMat(dpc22);

    LOGD("trans1");
    printMat(trans1);

    LOGD("trans2");
    printMat(trans2);

*/
//    LOGD("ConvertTo");
    trans1.convertTo(trans1,CV_64FC1);//CV_64FC1: 64-bit, float, 1 channel
    trans2.convertTo(trans2,CV_64FC1);

//    LOGD("Normalize");
    normalize(trans1, trans1, -1, 1, CV_MINMAX);
    normalize(trans2, trans2, -1, 1, CV_MINMAX);

//    LOGD("pushBack");
    vector<cv::Mat> transferFunctionList;
    transferFunctionList.push_back(trans1);
    transferFunctionList.push_back(trans2);

//    LOGD("CropHorz");
    // Crop to square
    /*
    dpc11 = dpc11 (CellScopeCropHorz);
    dpc12 = dpc12 (CellScopeCropHorz);
    dpc21 = dpc21 (CellScopeCropHorz);
    dpc22 = dpc22 (CellScopeCropHorz);
    */

    //Compute DPC Images
//    LOGD("Compute DPC Images");
    cv::Mat dpc1 = calcDPC(dpc11,dpc12);
    cv::Mat dpc2 = calcDPC(dpc21,dpc22);

    vector<cv::Mat> dpcList;
    dpcList.push_back(dpc1);
    dpcList.push_back(dpc2);

//    LOGD("Compute qDPC Image");
    double reg = 1.;//std::atof(regVal);
    Mat ph_dpc = qDPC_loop(dpcList, transferFunctionList, reg);
    normalize(ph_dpc, ph_dpc, -0.3, 1.4, CV_MINMAX);

    //LOGD("Apply Colormap");
    Mat cm_ph_dpc;
    cv::applyColorMap(ph_dpc, cm_ph_dpc, COLORMAP_COOL);

    //LOGD("Normalize");
    normalize(ph_dpc, ph_dpc, 0, 255, CV_MINMAX);
    //LOGD("Save qDPC Image");
    //imwrite("/storage/emulated/0/Holoscope/phaseimage.jpeg", ph_dpc);

    return ph_dpc;
}

